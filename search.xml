<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的博客</title>
      <link href="/2020/06/12/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/06/12/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS异步编程及常见面试题</title>
      <link href="/2019/09/21/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/09/21/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-异步编程及常考面试题"><a href="#JS-异步编程及常考面试题" class="headerlink" title="JS 异步编程及常考面试题"></a>JS 异步编程及常考面试题</h1><h2 id="并发（concurrency）和并行（parallelism）区别"><a href="#并发（concurrency）和并行（parallelism）区别" class="headerlink" title="并发（concurrency）和并行（parallelism）区别"></a>并发（concurrency）和并行（parallelism）区别</h2><a id="more"></a><blockquote><p>涉及面试题：并发与并行的区别？</p></blockquote><p>异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。</p><p>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p><p>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p><h2 id="回调函数（Callback）"><a href="#回调函数（Callback）" class="headerlink" title="回调函数（Callback）"></a>回调函数（Callback）</h2><blockquote><p>涉及面试题：什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</p></blockquote><p>回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码看起来不利于阅读和维护，当然，你可能会想说解决这个问题还不简单，把函数分开来写不就得了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url1, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">secondAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax(url2, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。</p><p>回调地狱的根本问题就是：</p><ol><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li><li>嵌套函数一多，就很难处理错误</li></ol><p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>涉及面试题：你理解的 Generator 是什么？</p></blockquote><p><code>Generator</code> 算是 ES6 中难理解的概念之一了，<code>Generator</code> 最大的特点就是可以控制函数的执行。我们讲一讲 <code>Generator</code> 的一些容易困惑的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>你也许会疑惑为什么会产生与你预想不同的值，逐行代码分析一下原因</p><ul><li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li><li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li><li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li><li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li></ul><p><code>Generator</code> 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 <code>Generator</code> 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p></blockquote><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p><ol><li>等待中（pending）</li><li>完成了 （resolved）</li><li>拒绝了（rejected）</li></ol><p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">'reject'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure><p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>前面都是在讲述 <code>Promise</code> 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 <code>Promise</code>，错误需要通过回调函数捕获。</p><h2 id="async-及-await"><a href="#async-及-await" class="headerlink" title="async 及 await"></a>async 及 await</h2><blockquote><p>涉及面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？</p></blockquote><p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()) <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure><p><code>async</code> 就是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，和 <code>then</code> 中处理返回值一样，并且 <code>await</code> 只能配套 <code>async</code> 使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async</code> 和 <code>await</code> 可以说是异步终极解决方案了，相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 <code>then</code> 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 会导致性能上的降低。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="keyword">await</span> fetch(url)</span><br><span class="line">  <span class="keyword">await</span> fetch(url1)</span><br><span class="line">  <span class="keyword">await</span> fetch(url2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一个使用 <code>await</code> 的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure><p>对于以上代码你可能会有疑惑，让我来解释下原因</p><ul><li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<code>generator</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li><li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li></ul><p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code> 的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p><h2 id="常用定时器函数"><a href="#常用定时器函数" class="headerlink" title="常用定时器函数"></a>常用定时器函数</h2><blockquote><p>涉及面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p></blockquote><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。我们先来讲讲最常用的<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p><p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，我们可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确，网上借鉴的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span>+h, <span class="string">'分：'</span>+m, <span class="string">'毫秒：'</span>+s, <span class="string">'秒向上取整：'</span>+sCeil, <span class="string">'代码执行时间：'</span>+offset, <span class="string">'下次循环间隔'</span>+currentInterval) </span><br><span class="line"></span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure><p>接下来我们来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p><p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">  sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure><p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p><p>如果你有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">  <span class="keyword">let</span> startTime = now()</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">setInterval(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>异步编程相关内容很多，需要继续学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript JS异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop那些事儿</title>
      <link href="/2019/09/16/EventLoop%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2019/09/16/EventLoop%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>在实践的过程中，你是否遇到过以下场景，为什么 <code>setTimeout</code> 会比 <code>Promise</code> 后执行，明明代码写在 <code>Promise</code> 之前。这其实涉及到了 Event Loop 相关的知识，我们来详细地了解 Event Loop 相关知识，知道 JS 异步运行代码的原理。</p><a id="more"></a><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote><p>涉及面试题：进程与线程区别？JS 单线程带来的好处？</p></blockquote><p>相信大家经常会听到 JS 是<strong>单线程</strong>执行的，但是你是否疑惑过什么是线程？</p><p>讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU <strong>工作时间片</strong>的一个描述。</p><p>进程描述了 CPU 在<strong>运行指令及加载和保存上下文所需的时间</strong>，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。</p><p>把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><p>上文说到了 JS 引擎线程和渲染线程，大家应该都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是<strong>互斥</strong>的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><blockquote><p>涉及面试题：什么是执行栈？</p></blockquote><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8xMy8xNjcwZDJkMjBlYWQzMmVj?x-oss-process=image/format,png" alt></p><p>执行栈可视化</p><p>当开始执行 JS 代码时，首先会执行一个 <code>main</code> 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p><p>平时在开发中，大家也可以在报错中找到执行栈的痕迹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8xMy8xNjcwYzBlMjE1NDAwOTBj?x-oss-process=image/format,png" alt></p><p>函数执行顺序</p><p>大家可以在上图清晰的看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。</p><p>当我们使用递归的时候，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8xMy8xNjcwYzEyOGFjY2U5NzVm?x-oss-process=image/format,png" alt></p><p>爆栈</p><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><blockquote><p>涉及面试题：异步代码执行顺序？解释一下什么是 Event Loop ？</p></blockquote><p>上一小节我们讲到了什么是执行栈，大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被<strong>挂起</strong>并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8yMy8xNjc0MGZhNGNkOWM2OTM3?x-oss-process=image/format,png" alt></p><p>事件循环</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 <strong>微任务</strong>（microtask） 和 <strong>宏任务</strong>（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。下面来看以下代码的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：新的浏览器中不是如上打印的，因为 await 变快了，具体内容可以往下看</p></blockquote><p>首先先来解释下上述代码的 <code>async</code> 和 <code>await</code> 的执行顺序。当我们调用 <code>async1</code> 函数时，会马上输出 <code>async2 end</code>，并且函数返回一个 <code>Promise</code>，接下来在遇到 <code>await</code>的时候会就让出线程开始执行 <code>async1</code> 外的代码，所以我们完全可以把 <code>await</code> 看成是<strong>让出线程</strong>的标志。</p><p>然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 <code>await</code> 的位置执行返回的 <code>Promise</code> 的 <code>resolve</code> 函数，这又会把 <code>resolve</code> 丢到微任务队列中，接下来去执行 <code>then</code> 中的回调，当两个 <code>then</code> 中的回调全部执行完毕以后，又会回到 <code>await</code> 的位置处理返回值，这时候你可以看成是 <code>Promise.resolve(返回值).then()</code>，然后 <code>await</code> 后的代码全部被包裹进了 <code>then</code> 的回调中，所以 <code>console.log(&#39;async1 end&#39;)</code> 会优先执行于 <code>setTimeout</code>。</p><p>如果你觉得上面这段解释还是有点绕，那么我把 <code>async</code> 的这两个函数改造成你一定能理解的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">  <span class="comment">// Promise.resolve() 将代码插入微任务队列尾部</span></span><br><span class="line">  <span class="comment">// resolve 再次插入微任务队列尾部</span></span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve())</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说，如果 <code>await</code> 后面跟着 <code>Promise</code> 的话，<code>async1 end</code> 需要等待三个 tick 才能执行到。那么其实这个性能相对来说还是略慢的，所以 V8 团队借鉴了 Node 8 中的一个 Bug，在引擎底层将三次 tick 减少到了二次 tick。但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 <a href="https://github.com/tc39/ecma262/pull/1250" target="_blank" rel="noopener">PR</a>，目前已被同意这种做法。</p><p>所以 Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li></ul><p>所以以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务，所以会有以上的打印。</p><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>MutationObserver</code>，其中 <code>process.nextTick</code> 为 Node 独有。</p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>。</p><p>这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，浏览器会<strong>先执行一个宏任务</strong>，接下来有异步代码的话才会先执行微任务。</p><h2 id="Node-中的-Event-Loop"><a href="#Node-中的-Event-Loop" class="headerlink" title="Node 中的 Event Loop"></a>Node 中的 Event Loop</h2><blockquote><p>涉及面试题：Node 中的 Event Loop 和浏览器中的有什么区别？process.nexttick 执行顺序？</p></blockquote><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p><p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8xMy8xNjcwYzNmZTNmOWE1ZTJi?x-oss-process=image/format,png" alt></p><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>timers 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code> 回调，并且是由 poll 阶段控制的。</p><p>同样，在 Node 中定时器指定的时间也不是准确时间，只能是<strong>尽快</strong>执行。</p><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>I/O 阶段会处理一些上一轮循环中的<strong>少数未执行</strong>的 I/O 回调</p><h3 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle, prepare"></a>idle, prepare</h3><p>idle, prepare 阶段内部实现，这里就忽略不讲了。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p><ol><li>回到 timer 阶段执行回调</li><li>执行 I/O 回调</li></ol><p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li><li>如果 poll 队列为空时，会有两件事发生<ul><li>如果有 <code>setImmediate</code> 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li><li>如果没有 <code>setImmediate</code> 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>check 阶段执行 <code>setImmediate</code></p><h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>close callbacks 阶段执行 close 事件</p><p>在以上的内容中，我们了解了 Node 中的 Event Loop 的执行顺序，接下来我们将会通过代码的方式来深入理解这块内容。</p><p>首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p>上面介绍的都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS8xNC8xNjcxMGZiODBkZDQyZDI3?x-oss-process=image/format,png" alt></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer21'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p><p>最后我们来讲讲 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码，大家可以发现无论如何，永远都是先把 nextTick 全部打印出来。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 EventLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>壹题--[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)答案解析</title>
      <link href="/2019/09/10/%E5%A3%B9%E9%A2%98--%5B&#39;1&#39;,&#39;2&#39;,&#39;3&#39;%5D.map(parseInt)%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/10/%E5%A3%B9%E9%A2%98--%5B&#39;1&#39;,&#39;2&#39;,&#39;3&#39;%5D.map(parseInt)%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>今天在【<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question" target="_blank" rel="noopener">壹题</a>】中看到了这样一个题目：</p><blockquote><p>[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ？</p></blockquote><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是<strong>[1, NaN, NaN]</strong>，这里记录一下看了大神们的分析后的总结。</p><a id="more"></a><hr><p>这个主要是讲<strong>JS的映射与解析</strong><br>早在 2013年, 加里·伯恩哈德就在微博上发布了以下代码段:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// [10, NaN, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h4><p><code>parseInt()</code> 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> intValue = <span class="built_in">parseInt</span>(string[, radix]);</span><br></pre></td></tr></table></figure><p><code>string</code>   要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。<br><code>radix</code> 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。<br><code>返回值</code> 返回一个整数或NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">2</span>); <span class="comment">// 4 -&gt; converts 100 in base 2 to base 10</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>在<code>radix</code>为 undefined，或者<code>radix</code>为 0 或者没有指定的情况下，JavaScript 作如下处理:</p><ul><li>如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制). 如果字符串 string 以”0”开头,</li><li>基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5  规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出<code>radix</code>参数的值。</li><li>如果字符串 string 以其它任何值开头，则基数是10 (十进制)。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">更多详见parseInt | MDN</a></li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[, array]]</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// Return element for new_array</span></span><br><span class="line"> &#125;[, thisArg])</span><br></pre></td></tr></table></figure><p>可以看到<code>callback</code>回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。<br><code>currentValue</code>是callback 数组中正在处理的当前元素。<br><code>index</code>可选, 是callback 数组中正在处理的当前元素的索引。<br><code>array</code>可选, 是callback map 方法被调用的数组。<br>另外还有<code>thisArg</code>可选, 执行 callback 函数时使用的this 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.map(<span class="function">(<span class="params">num</span>) =&gt;</span> num + <span class="number">1</span>); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">更多详见Array.prototype.map() | MDN</a></p><h4 id="回到我们碰到的问题"><a href="#回到我们碰到的问题" class="headerlink" title="回到我们碰到的问题"></a>回到我们碰到的问题</h4><p>回到我们真实的事例上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br></pre></td></tr></table></figure><p>对于每个迭代<code>map</code>, <code>parseInt()</code>传递两个参数: 字符串和基数。<br>所以实际执行的的代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即返回的值分别为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN, 3 不是二进制</span></span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">// 1, NaN, NaN</span></span><br></pre></td></tr></table></figure><p>由此，加里·伯恩哈德例子也就很好解释了，这里不再赘述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// [10, NaN, 2, 3, 4]  // 只要item的每一位小于index的值就满足，否则NaN</span></span><br></pre></td></tr></table></figure><h4 id="如何在现实世界中做到这一点"><a href="#如何在现实世界中做到这一点" class="headerlink" title="如何在现实世界中做到这一点"></a>如何在现实世界中做到这一点</h4><p>如果其实实际上想要循环访问字符串数组, 该怎么办？ <code>map()</code>然后把它换成数字？使用编号!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10, 10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure><hr><p>本文到底就结束啦~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Cookie、HttpOnly那点事儿</title>
      <link href="/2019/09/10/%E6%B5%85%E8%B0%88Cookie%E3%80%81HttpOnly%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/"/>
      <url>/2019/09/10/%E6%B5%85%E8%B0%88Cookie%E3%80%81HttpOnly%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="一-Cookie介绍"><a href="#一-Cookie介绍" class="headerlink" title="一. Cookie介绍"></a>一. Cookie介绍</h4><p>众说周知，Cookie 在浏览器里可以保存一些例如 tokenId 等的一些控制系统登 录状态的数据。通过 Cookie 和 Session 技术来实现记录访问者的一些基本信息</p><a id="more"></a>, Cookie 可以翻译为“小甜品，小饼干” ，Cookie 几乎在所有的网络中都会出现，Cookie 实际上是指小量信息，是由 Web 服务器创建的，将信息存储在用户计算机上的文件。一般习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。<p>有些Cookie 是有限制的，一旦超过时间限制，就会被系统删除。很多人担心Cookie 会泄露用户的一些信息。但这是多余的，Cookie 是不能通过跨域来访问的，还有一些对象是不能脱离Cookie 来实现的，比如Session。这里还有一个点，就是客户端Cookie 数量最多为300个，每个不能超过4kb, 每个web站点设置的cookie 数量不能超过20个。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">MDN cookie详解</a></p><h4 id="二-JS-操作-Cookie"><a href="#二-JS-操作-Cookie" class="headerlink" title="二.JS 操作 Cookie"></a>二.JS 操作 Cookie</h4><p>一般来说，只有服务器操作Cookie 才能保证一些必要的安全。但有时候，可能需要前端来增删改查 Cookie, 这个时候咱们的主角出现了——HttpOnly<br>HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）。</p><p>这个意思就是说，如果某一个Cookie 选项被设置成 HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，JS是操作不了的，对于 document.cookie 来说是透明的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi01NTYyN2FmMDYyMjFjNjM4YWMyNzRmZTc2MmYwZjk0OV9oZC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>以 Google 翻译为例子，初次打开时，Cookie里面是这样的一共有4条记录，注意第二个最右侧倒数第三个字段有一个√， 这个对勾表明这条记录是 HttpOnly = true 的，对于JS，你是拿不到的。我们来试一下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi02MGI1ZjdmMTcwMWNkMTg4NTdmNmNjMGU3ZWY0NTAxZV9oZC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>JS获取Cookie 的时候就会跳过HttpOnly = true 的Cookie 记录。当然，既然拿不到，那就跟别说删改了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 Cookie httponly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>...args剩余参数（展开运算符）的用法及与arguments的区别</title>
      <link href="/2019/09/02/args%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%EF%BC%88%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E4%B8%8Earguments%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/09/02/args%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%EF%BC%88%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E4%B8%8Earguments%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h5 id="…args剩余参数-展开运算符"><a href="#…args剩余参数-展开运算符" class="headerlink" title="…args剩余参数(展开运算符)"></a>…args剩余参数(展开运算符)</h5><p> 允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p><a id="more"></a><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(<span class="rest_arg">...theArgs</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce((previous, current) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"> </span><br><span class="line">console.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br></pre></td></tr></table></figure><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>如果函数的最后一个命名参数以…为前缀，则它将成为一个数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。</p><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(a, b, <span class="rest_arg">...theArgs</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。</p><h6 id="函数调用中使用展开运算符"><a href="#函数调用中使用展开运算符" class="headerlink" title="函数调用中使用展开运算符"></a>函数调用中使用展开运算符</h6><p>在以前我们会使用apply方法来将一个数组展开成多个参数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(a, b, c)</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">test.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure><p>如上，我们把args数组当作实参传递给了a,b,c，这边正是利用了Function.prototype.apply的特性。</p><p>不过有了ES6，我们就可以更加简洁地来传递数组参数：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">test</span>(a,b,c) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">args</span> = [0,1,2];</span><br><span class="line"><span class="keyword">test</span>(...<span class="keyword">args</span>);</span><br></pre></td></tr></table></figure><p>我们使用…展开运算符就可以把args直接传递给test()函数。</p><h6 id="数组字面量中使用展开运算符"><a href="#数组字面量中使用展开运算符" class="headerlink" title="数组字面量中使用展开运算符"></a>数组字面量中使用展开运算符</h6><p>在ES6的世界中，我们可以直接加一个数组直接合并到另外一个数组当中：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">var arr2=[...arr1,<span class="string">'d'</span>,<span class="string">'e'</span>]; //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure><p>展开运算符也可以用在push函数中，可以不用再用apply()函数来合并两个数组：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">var arr2=[<span class="string">'d'</span>,<span class="string">'e'</span>];</span><br><span class="line">arr1.push(...arr2); //[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>]</span><br></pre></td></tr></table></figure><h6 id="用于解构赋值"><a href="#用于解构赋值" class="headerlink" title="用于解构赋值"></a>用于解构赋值</h6><p>解构赋值也是ES6中的一个特性，而这个展开运算符可以用于部分情景：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [ar<span class="name">g1</span>,ar<span class="name">g2</span>,...ar<span class="name">g3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">ar<span class="name">g1</span> <span class="comment">//1</span></span><br><span class="line">ar<span class="name">g2</span> <span class="comment">//2</span></span><br><span class="line">ar<span class="name">g3</span> <span class="comment">//['3','4']</span></span><br></pre></td></tr></table></figure><p>展开运算符在解构赋值中的作用跟之前的作用看上去是相反的，将多个数组项组合成了一个新数组。<br>不过要注意，解构赋值中展开运算符只能用在最后：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [arg1,...arg2,arg3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h6 id="类数组对象变成数组"><a href="#类数组对象变成数组" class="headerlink" title="类数组对象变成数组"></a>类数组对象变成数组</h6><p>展开运算符可以将一个类数组对象变成一个真正的数组对象：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>])  <span class="comment">// a : Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">let b=[...a]    <span class="comment">//  (5) [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h6 id="ES7草案中的对象展开运算符"><a href="#ES7草案中的对象展开运算符" class="headerlink" title="ES7草案中的对象展开运算符"></a>ES7草案中的对象展开运算符</h6><p>ES7中的对象展开运算符符可以让我们更快捷地操作对象：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x,y,...z&#125;=&#123;<span class="string">x:</span><span class="number">1</span>,<span class="string">y:</span><span class="number">2</span>,<span class="string">a:</span><span class="number">3</span>,<span class="string">b:</span><span class="number">4</span>&#125;;</span><br><span class="line">x; <span class="comment">//1</span></span><br><span class="line">y; <span class="comment">//2</span></span><br><span class="line">z; <span class="comment">//&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure><p>如上，我们可以将一个对象当中的对象的一部分取出来成为一个新对象赋值给展开运算符的参数。<br>同时，我们也可以像数组插入那样将一个对象插入另外一个对象当中：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let z=&#123;<span class="string">a:</span><span class="number">3</span>,<span class="string">b:</span><span class="number">4</span>&#125;;</span><br><span class="line">let n=&#123;<span class="string">x:</span><span class="number">1</span>,<span class="string">y:</span><span class="number">2</span>,...z&#125;;</span><br><span class="line">n; <span class="comment">//&#123;x:1,y:2,a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure><p>另外还要很多用处，比如可以合并两个对象：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;x:<span class="number">1</span>,y:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b=&#123;z:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> ab=&#123;<span class="params">...</span>a,<span class="params">...</span>b&#125;;</span><br><span class="line">ab <span class="comment">//&#123;x:1,y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure><h5 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h5><p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p><p>例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0] 也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。</p><p>因此，无需明确命名参数，就可以重写函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);   <span class="comment">// 此处将打印message参数的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="检测参数个数"><a href="#检测参数个数" class="headerlink" title="检测参数个数"></a>检测参数个数</h6><p>还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。</p><p>下面的代码将输出每次调用函数使用的参数个数：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function howM<span class="literal">any</span>Args() &#123;</span><br><span class="line">  alert(arguments.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">howM<span class="literal">any</span>Args(<span class="string">"string"</span>, <span class="number">45</span>);</span><br><span class="line">howM<span class="literal">any</span>Args();</span><br><span class="line">howM<span class="literal">any</span>Args(<span class="number">12</span>);   //  上面这段代码将依次显示 <span class="string">"2"</span>、<span class="string">"0"</span> 和 <span class="string">"1"</span>。</span><br></pre></td></tr></table></figure><h6 id="模拟函数重载"><a href="#模拟函数重载" class="headerlink" title="模拟函数重载"></a>模拟函数重载</h6><p>用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">5</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">doAdd(<span class="number">10</span>);<span class="comment">//输出 "15"</span></span><br><span class="line">doAdd(<span class="number">40</span>, <span class="number">20</span>);<span class="comment">//输出 "60"</span></span><br></pre></td></tr></table></figure><p>当只有一个参数时，doAdd() 函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，doAdd(10) 输出的是 “15”，而 doAdd(40, 20) 输出的是 “60”。</p><h5 id="…args剩余参数和-arguments对象的区别"><a href="#…args剩余参数和-arguments对象的区别" class="headerlink" title="…args剩余参数和 arguments对象的区别"></a>…args剩余参数和 arguments对象的区别</h5><p><strong>剩余参数和 arguments对象之间的区别主要有三个：</strong></p><pre><code>1.剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。2.arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。3.arguments对象还有一些附加的属性 （如callee属性）。</code></pre><h6 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h6><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">MDN 展开语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">MDN Arguments 对象</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 剩余参数 arguments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JavaScript继承的几种方式</title>
      <link href="/2019/08/31/%E8%AF%A6%E8%A7%A3JavaScript%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/08/31/%E8%AF%A6%E8%A7%A3JavaScript%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="属性拷贝"><a href="#属性拷贝" class="headerlink" title="属性拷贝"></a>属性拷贝</h3><blockquote><p>就是将对象的成员复制一份给需要继承的对象</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父对象</span></span><br><span class="line"><span class="keyword">var</span> superObj = &#123;</span><br><span class="line">  name: <span class="string">'Li'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  friends: [<span class="string">'小明'</span>, <span class="string">'小李'</span>, <span class="string">'小赵'</span>],</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建需要继承的子对象</span></span><br><span class="line"><span class="keyword">var</span> subObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始拷贝属性(使用for...in...循环)</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i <span class="keyword">in</span> superObj )&#123;</span><br><span class="line">  subObj[i] = superObj[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subObj)</span><br><span class="line"><span class="built_in">console</span>.log(superObj)</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong></p><blockquote><p>如果继承过来的成员是引用类型的话,<br>那么这个引用类型的成员在父对象和子对象之间是共享的,<br>也就是说修改了之后, 父子对象都会受到影响.</p></blockquote><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote><p> 将父类的实例作为子类的原型</p></blockquote><p><strong>父类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br></pre></td></tr></table></figure><p><strong>子类：</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Cat</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">cat</span>.prototype = new Animal()</span><br><span class="line"><span class="keyword">cat</span>.prototype.name = <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">cat</span> = new <span class="keyword">Cat</span>();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span>.name)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span>.eat('fish'))</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span>.<span class="keyword">sleep</span>())</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span> instanceof Animal)  <span class="comment">// true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span> instanceof <span class="keyword">Cat</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>1.纯粹的继承关系，实例是子类的实例，也是父类的实例<br>    2.父类新增原型方法/原型属性，子类都能访问到<br>    3.简单，易于实现</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1.可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则                               必须放在new Animal()这样的语句之后执行。<br>   2.无法实现多继承<br>   3.来自原型对象的所有属性被所有实例共享<br>   4.创建子类实例时，无法向父类构造函数传参</p></blockquote><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><blockquote><p>使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p></blockquote><p><strong>父类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br></pre></td></tr></table></figure><p><strong>子类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name= name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal);   <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>1.解决了1中，子类实例共享父类引用属性的问题<br> 2.创建子类实例时，可以向父类传递参数<br> 3.可以实现多继承（call多个父类对象）</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1.实例并不是父类的实例，只是子类的实例<br>   2.只能继承父类的实例属性和方法，不能继承原型属性/方法<br>   3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p></blockquote><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote><p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p></blockquote><p><strong>父类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br></pre></td></tr></table></figure><p><strong>子类：</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Cat</span>(name)&#123;</span><br><span class="line">  Animal.call(this);</span><br><span class="line">  this.name = name || 'Tom';</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Cat</span>.prototype = new Animal();</span><br><span class="line"></span><br><span class="line"><span class="comment">//修复构造函数指向</span></span><br><span class="line"><span class="keyword">Cat</span>.prototype.constructor = <span class="keyword">Cat</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">cat</span> = new <span class="keyword">Cat</span>();</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span>.name);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span>.<span class="keyword">sleep</span>());</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span> instanceof Animal); <span class="comment">// true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">cat</span> instanceof <span class="keyword">Cat</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>1.弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法<br>   2.既是子类的实例，也是父类的实例<br>   3.不存在引用属性共享问题<br>   4.可传参,函数可复用</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p></blockquote><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><blockquote><p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p></blockquote><p><strong>父类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br></pre></td></tr></table></figure><p><strong>子类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">  <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  Super.prototype = Animal.prototype;</span><br><span class="line">  <span class="comment">//将实例作为子类的原型</span></span><br><span class="line">  Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Cat.prototype.constructor = Cat; <span class="comment">// 需要修复下构造函数</span></span><br></pre></td></tr></table></figure><p><strong>或者：</strong></p><blockquote><p>继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Cat,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>堪称完美</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>实现较为复杂</p></blockquote><h3 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h3><blockquote><p>在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单,使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，这段代码可以看成 Animal.call(this, name)。Class 的本质就是函数</p></blockquote><p><strong>父类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个动物类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Animal'</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃：'</span> + food);</span><br></pre></td></tr></table></figure><p><strong>子类：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">　　　　<span class="keyword">super</span>(name);&lt;br&gt;　　　　<span class="keyword">this</span>.name= name || <span class="symbol">'Anima</span>l';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="type">Cat</span>();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof <span class="type">Animal</span>); <span class="comment">// true</span></span><br><span class="line">console.log(cat instanceof <span class="type">Cat</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 JS继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 函数式编程</title>
      <link href="/2019/08/30/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/08/30/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>昨天进行了人人网的面试，其中在二面中面试官问了“什么是函数式编程”这个问题，我只是听说过这个东西，但是让我讲就讲不出来，最后结束的时候给我的评价就是</p><blockquote><p>js基础还行, 但是深入理解不够, 还有一个最关键的就是知识点看到了最好搞懂搞透彻, 不可以自己推测, 但是可以自己做demo实验自己的推测</p></blockquote><p>经过这次面试后也发现和认识了自己的不足的地方，在这里也总结记录一下自己学习的JS的函数式编程</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="一、什么是函数式编程？"><a href="#一、什么是函数式编程？" class="headerlink" title="一、什么是函数式编程？"></a>一、什么是函数式编程？</h3><blockquote><p>我的理解是函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数可以看成没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的。.函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用。函数式编程我觉得更贴近于数学思想或者说计算。</p></blockquote><h3 id="二、函数式编程的特性"><a href="#二、函数式编程的特性" class="headerlink" title="二、函数式编程的特性"></a>二、函数式编程的特性</h3><h6 id="1-函数是”第一等公民”"><a href="#1-函数是”第一等公民”" class="headerlink" title="1.函数是”第一等公民”"></a>1.函数是”第一等公民”</h6><p>所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。<br>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">print</span> = <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span>&#123; console.log(i);&#125;;</span><br><span class="line">　　[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="keyword">forEach</span>(<span class="keyword">print</span>);</span><br></pre></td></tr></table></figure><h6 id="2-只用”表达式”，不用”语句”"><a href="#2-只用”表达式”，不用”语句”" class="headerlink" title="2.只用”表达式”，不用”语句”"></a>2.只用”表达式”，不用”语句”</h6><p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。<br>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。<br>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p><h6 id="3-没有”副作用”"><a href="#3-没有”副作用”" class="headerlink" title="3.没有”副作用”"></a>3.没有”副作用”</h6><p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><h6 id="4-不修改状态"><a href="#4-不修改状态" class="headerlink" title="4.不修改状态"></a>4.不修改状态</h6><p>在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式。这里所说的’变量’是不能被修改的。所有的变量只能被赋一次初值。（下面会详细介绍变量被函数代替）</p><h6 id="5-引用透明性"><a href="#5-引用透明性" class="headerlink" title="5.引用透明性"></a>5.引用透明性</h6><p>函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。</p><h2 id="三、函数式编程常用核心概念和技术"><a href="#三、函数式编程常用核心概念和技术" class="headerlink" title="三、函数式编程常用核心概念和技术"></a>三、函数式编程常用核心概念和技术</h2><h6 id="1-纯函数"><a href="#1-纯函数" class="headerlink" title="1.纯函数"></a>1.纯函数</h6><p>什么是纯函数呢？</p><p>对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。<br>举个栗子：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的</span></span><br><span class="line">xs.slice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">xs.slice(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">xs.splice(<span class="number">0</span>,<span class="number">3</span>);<span class="comment">// Array.splice会对原array造成影响，所以不纯</span></span><br><span class="line">xs.splice(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h6 id="2-函数柯里化（高级函数）"><a href="#2-函数柯里化（高级函数）" class="headerlink" title="2.函数柯里化（高级函数）"></a>2.函数柯里化（高级函数）</h6><p>高阶函数，就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。<br>我的理解：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>看一个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 柯里化之后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addX</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">addX(<span class="number">2</span>)(<span class="number">1</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>柯里化可以理解为是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。</p></blockquote><h6 id="3-函数组合"><a href="#3-函数组合" class="headerlink" title="3.函数组合"></a>3.函数组合</h6><p>为了解决函数嵌套过深，洋葱代码：h(g(f(x)))，我们需要用到“函数组合”，我们可以<br>来用柯里化来改他，让多个函数像拼积木一样。</p><p>函数编程的函数组合：两个纯函数组合之后返回了一个新函数,举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f,g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exclaim = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + <span class="string">"!"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> shout = compose( exclaim , toUpperCase );</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(shout(<span class="string">"hello world"</span>)); <span class="comment">//HELLO WORLD!</span></span><br></pre></td></tr></table></figure><p>可以对他简化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose=<span class="function">(<span class="params">f,g</span>)=&gt;</span>(<span class="function"><span class="params">x</span>=&gt;</span>f(g(x)))</span><br><span class="line"><span class="keyword">const</span> toUpperCase=<span class="function"><span class="params">x</span>=&gt;</span>x.toUpperCase()</span><br><span class="line"><span class="keyword">const</span> exclaim=<span class="function"><span class="params">x</span>=&gt;</span>x+<span class="string">'!'</span></span><br><span class="line"><span class="keyword">const</span> shout=compose(exclaim,toUpperCase)</span><br><span class="line"><span class="built_in">console</span>.log(shout(<span class="string">'hello world'</span>));  <span class="comment">//HELLO WORLD!</span></span><br></pre></td></tr></table></figure><p><strong>compose</strong>中的参数的顺序是随意的，这就类似于乘法中的交换律 <strong>x<em>y=y</em>x</strong>,<br>所以函数式编程贴近于数学计算。<br><img src="https://img-blog.csdnimg.cn/20190829211452652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="4-递归与尾递归"><a href="#4-递归与尾递归" class="headerlink" title="4.递归与尾递归"></a>4.递归与尾递归</h6><p>指函数内部的最后一个动作是函数调用。 该调用的返回值， 直接返回给函数。 函数调用自身， 称为递归。 如果尾调用自身， 就称为尾递归。 递归需要保存大量的调用记录， 很容易发生栈溢出错误， 如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录， 这样就不会发生栈溢出错误了。通俗点说，尾递归最后一步需要调用自身，并且之后不能有其他额外操作。<br>举个例子：我的理解为满足递归条件相当于捕鱼时先撒网，等达到递归边界即捕到鱼时，再返回自身及收网；尾递归就为当捕到鱼时鱼已经到你手里了，具体举个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是尾递归，无法优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;   <span class="comment">//这里的递归当到达边界条件时会把值返回给上一个调用它的函数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125; <span class="comment">//ES6强制使用尾递归</span></span><br><span class="line"><span class="comment">// 这里的尾递归就是当到底边界条件时直接将结果 return 出来</span></span><br></pre></td></tr></table></figure><p>我们看一下递归和尾递归执行过程：<br>递归：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum(n) &#123;</span><br><span class="line">    if (n === <span class="number">1</span>) return <span class="number">1</span>;</span><br><span class="line">    return n + sum(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span> + sum(<span class="number">4</span>))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + sum(<span class="number">3</span>)))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + sum(<span class="number">2</span>))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + (<span class="number">2</span> + sum(<span class="number">1</span>)))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + (<span class="number">2</span> + <span class="number">1</span>))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + <span class="number">3</span>)))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + <span class="number">6</span>))</span><br><span class="line">(<span class="number">5</span> + <span class="number">10</span>)</span><br><span class="line"><span class="number">15</span>      <span class="comment">//递归非常消耗内存，因为需要同时保存很多的调用帧，这样，就很容易发生“栈溢出”</span></span><br></pre></td></tr></table></figure><p>尾递归：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, total) &#123;</span><br><span class="line">    if (x === <span class="number">1</span>) &#123;</span><br><span class="line">        return x + total;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum(x - <span class="number">1</span>, x + total);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">sum(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">9</span>)</span><br><span class="line">sum(<span class="number">2</span>, <span class="number">12</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">14</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>整个计算过程是线性的，调用一次sum(x, total)后，会进入下一个栈，相关的数据信息和跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。 在ECMAScript 6，我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同时拥有数学表达能力和while的效能。</p><h6 id="5-惰性计算（求值）"><a href="#5-惰性计算（求值）" class="headerlink" title="5.惰性计算（求值）"></a>5.惰性计算（求值）</h6><p>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算使你可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。简单的来说就是：</p><blockquote><p><strong>按需索取，能不多做事，绝不多做</strong></p></blockquote><p>这里有自己实现的简单的惰性求值<br><a href="https://www.ctolib.com/mip/wangdashuaihenshuai-lazy.html" target="_blank" rel="noopener">用JavaScript写一个惰性求值的最简实现</a><br>惰性求值官方文档<br><a href="https://github.com/dtao/lazy.js" target="_blank" rel="noopener">官方文档</a></p><h2 id="四、函数式编程总结"><a href="#四、函数式编程总结" class="headerlink" title="四、函数式编程总结"></a>四、函数式编程总结</h2><p>1.函数式编程中的每个符号都是 const 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。<br>2.函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。<br>3.函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="noopener">JavaScript函数式编程指南</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 高级函数 JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识点总结JS篇</title>
      <link href="/2019/08/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93JS%E7%AF%87/"/>
      <url>/2019/08/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93JS%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系"><a href="#DOM元素e的e-getAttribute-propName-和e-propName有什么区别和联系" class="headerlink" title="DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系"></a>DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系</h3><ul><li><p>e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中<strong>设置的属性</strong></p></li><li><p>e.propName通常是在HTML文档中访问特定元素的<strong>特性</strong>，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问</p><a id="more"></a></li><li><p>e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）</p></li><li><p>e.propName返回值可能是字符串、布尔值、对象、undefined等</p></li><li><p>大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性</p></li><li><p>一些布尔属性<code>&lt;input hidden/&gt;</code>的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property</p></li><li><p>像<code>&lt;a href=&quot;../index.html&quot;&gt;link&lt;/a&gt;</code>中href属性，转换成property的时候需要通过转换得到完整URL</p></li><li><p>一些attribute和property不是一一对应如：form控件中<code>&lt;input value=&quot;hello&quot;/&gt;</code>对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property</p></li></ul><h3 id="offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><ul><li>offsetWidth/offsetHeight返回值包含<strong>content + padding + border</strong>，效果与e.getBoundingClientRect()相同</li><li>clientWidth/clientHeight返回值只包含<strong>content + padding</strong>，如果有滚动条，也<strong>不包含滚动条</strong></li><li>scrollWidth/scrollHeight返回值包含<strong>content + padding + 溢出内容的尺寸</strong></li></ul><h3 id="XMLHttpRequest通用属性和方法"><a href="#XMLHttpRequest通用属性和方法" class="headerlink" title="XMLHttpRequest通用属性和方法"></a>XMLHttpRequest通用属性和方法</h3><ol><li><code>readyState</code>:表示请求状态的整数，取值：<ul><li>UNSENT（0）：对象已创建</li><li>OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求</li><li>HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到</li><li>LOADING(3)：响应体正在接收</li><li>DONE(4)：数据传输完成或者传输产生错误</li></ul></li><li><code>onreadystatechange</code>：readyState改变时调用的函数</li><li><code>status</code>：服务器返回的HTTP状态码（如，200， 404）</li><li><code>statusText</code>:服务器返回的HTTP状态信息（如，OK，No Content）</li><li><code>responseText</code>:作为字符串形式的来自服务器的完整响应</li><li><code>responseXML</code>: Document对象，表示服务器的响应解析成的XML文档</li><li><code>abort()</code>:取消异步HTTP请求</li><li><code>getAllResponseHeaders()</code>: 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行</li><li><code>getResponseHeader(headerName)</code>:返回headName对应的报头值</li><li><code>open(method, url, asynchronous [, user, password])</code>:初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证</li><li><code>setRequestHeader(name, value)</code>:设置HTTP报头</li><li><code>send(body)</code>:对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</li></ol><h3 id="focus-blur与focusin-focusout的区别与联系"><a href="#focus-blur与focusin-focusout的区别与联系" class="headerlink" title="focus/blur与focusin/focusout的区别与联系"></a>focus/blur与focusin/focusout的区别与联系</h3><ol><li>focus/blur不冒泡，focusin/focusout冒泡</li><li>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</li><li>可获得焦点的元素：<ol><li>window</li><li>链接被点击或键盘操作</li><li>表单空间被点击或键盘操作</li><li>设置<code>tabindex</code>属性的元素被点击或键盘操作</li></ol></li></ol><h3 id="mouseover-mouseout与mouseenter-mouseleave的区别与联系"><a href="#mouseover-mouseout与mouseenter-mouseleave的区别与联系" class="headerlink" title="mouseover/mouseout与mouseenter/mouseleave的区别与联系"></a>mouseover/mouseout与mouseenter/mouseleave的区别与联系</h3><ol><li>mouseover/mouseout是标准事件，<strong>所有浏览器都支持</strong>；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持</li><li>mouseover/mouseout是<strong>冒泡</strong>事件；mouseenter/mouseleave<strong>不冒泡</strong>。需要为<strong>多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能</strong></li><li>标准事件模型中event.target表示发生移入/出的元素,<strong>vent.relatedTarget</strong>对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，<strong>event.toElement</strong>表示移出的目标元素，<strong>event.fromElement</strong>表示移入时的来源元素</li></ol><p>例子：鼠标从div#target元素移出时进行处理，判断逻辑如下：</p><pre><code>&lt;div id=&quot;target&quot;&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;var target = document.getElementById(&apos;target&apos;);if (target.addEventListener) {  target.addEventListener(&apos;mouseout&apos;, mouseoutHandler, false);} else if (target.attachEvent) {  target.attachEvent(&apos;onmouseout&apos;, mouseoutHandler);}function mouseoutHandler(e) {  e = e || window.event;  var target = e.target || e.srcElement;  // 判断移出鼠标的元素是否为目标元素  if (target.id !== &apos;target&apos;) {    return;  }  // 判断鼠标是移出元素还是移到子元素  var relatedTarget = event.relatedTarget || e.toElement;  while (relatedTarget !== target    &amp;&amp; relatedTarget.nodeName.toUpperCase() !== &apos;BODY&apos;) {    relatedTarget = relatedTarget.parentNode;  }  // 如果相等，说明鼠标在元素内部移动  if (relatedTarget === target) {    return;  }  // 执行需要操作  //alert(&apos;鼠标移出&apos;);}&lt;/script&gt;</code></pre><h3 id="sessionStorage-localStorage-cookie区别"><a href="#sessionStorage-localStorage-cookie区别" class="headerlink" title="sessionStorage,localStorage,cookie区别"></a>sessionStorage,localStorage,cookie区别</h3><ol><li>都会在浏览器端保存，有大小限制，同源限制</li><li>cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器</li><li>cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie</li><li>有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除</li><li>共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享</li><li>localStorage的修改会促发其他文档窗口的update事件</li><li>cookie有secure属性要求HTTPS传输</li><li>浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M</li></ol><h3 id="javascript跨域通信"><a href="#javascript跨域通信" class="headerlink" title="javascript跨域通信"></a>javascript跨域通信</h3><p>同源：两个文档同源需满足</p><ol><li>协议相同</li><li>域名相同</li><li>端口相同</li></ol><p>跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法</p><ul><li>如果是log之类的简单<strong>单项通信</strong>，新建<code>&lt;img&gt;</code>,<code>&lt;script&gt;</code>,<code>&lt;link&gt;</code>,<code>&lt;iframe&gt;</code>元素，通过src，href属性设置为目标url。实现跨域请求</li><li>如果请求<strong>json数据</strong>，使用<code>&lt;script&gt;</code>进行jsonp请求</li><li>现代浏览器中<strong>多窗口通信</strong>使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用</li><li>内部服务器代理请求跨域url，然后返回数据</li><li>跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部<strong><code>Access-Control-Allow-Origin: *</code></strong>即可像普通ajax一样访问跨域资源</li></ul><h3 id="javascript有哪几种数据类型"><a href="#javascript有哪几种数据类型" class="headerlink" title="javascript有哪几种数据类型"></a>javascript有哪几种数据类型</h3><p>六种基本数据类型</p><ul><li>undefined</li><li>null</li><li>string</li><li>boolean</li><li>number</li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">symbol</a>(ES6)</li></ul><p>三种引用类型</p><ul><li>Object</li><li>Function</li><li>Array</li></ul><h3 id="什么闭包-闭包有什么用"><a href="#什么闭包-闭包有什么用" class="headerlink" title="什么闭包,闭包有什么用"></a>什么闭包,闭包有什么用</h3><p><strong>闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量</strong>。闭包作用域链通常包括三个部分：</p><ol><li>函数本身作用域。</li><li>闭包定义时的作用域。</li><li>全局作用域。</li></ol><p>闭包常见用途：</p><ol><li>创建特权方法用于访问控制</li><li>事件处理程序及回调</li></ol><h3 id="javascript有哪几种方法定义函数"><a href="#javascript有哪几种方法定义函数" class="headerlink" title="javascript有哪几种方法定义函数"></a>javascript有哪几种方法定义函数</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function" target="_blank" rel="noopener">函数声明表达式</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="noopener">function操作符</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">Function 构造函数</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/arrow_functions" target="_blank" rel="noopener">ES6:arrow function</a></li></ol><p>重要参考资料：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope" target="_blank" rel="noopener">MDN:Functions_and_function_scope</a></p><h3 id="应用程序存储和离线web应用"><a href="#应用程序存储和离线web应用" class="headerlink" title="应用程序存储和离线web应用"></a>应用程序存储和离线web应用</h3><p>HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。<br>1.为html元素设置manifest属性:<code>&lt;html manifest=&quot;myapp.appcache&quot;&gt;</code>，其中后缀名只是一个约定，真正识别方式是通过<code>text/cache-manifest</code>作为MIME类型。所以需要配置服务器保证设置正确<br>2.manifest文件首行为<code>CACHE MANIFEST</code>，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头<br>3.url分为三种类型：<code>CACHE</code>:为默认类型。<code>NETWORK</code>：表示资源从不缓存。 <code>FALLBACK</code>:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">myapp.html</span><br><span class="line">myapp.css</span><br><span class="line">myapp.js</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">videos/ offline_help.html</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">cgi/</span><br></pre></td></tr></table></figure><h3 id="客户端存储localStorage和sessionStorage"><a href="#客户端存储localStorage和sessionStorage" class="headerlink" title="客户端存储localStorage和sessionStorage"></a>客户端存储localStorage和sessionStorage</h3><ul><li>localStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前</li><li>同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。</li><li>Storage对象通常被当做普通javascript对象使用：<strong>通过设置属性来存取字符串值</strong>，也可以通过<strong>setItem(key, value)设置</strong>，<strong>getItem(key)读取</strong>，<strong>removeItem(key)删除</strong>，<strong>clear()删除所有数据</strong>，<strong>length表示已存储的数据项数目</strong>，<strong>key(index)返回对应索引的key</strong></li></ul><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem('x', <span class="number">1</span>); <span class="comment">// storge x-&gt;1</span></span><br><span class="line">localStorage.getItem('x); <span class="comment">// return value of x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举所有存储的键值对</span></span><br><span class="line">for (<span class="built_in">var</span> i = <span class="number">0</span>, len = localStorage.length; i &lt; len; ++i ) &#123;</span><br><span class="line">    <span class="built_in">var</span> name = localStorage.<span class="built_in">key</span>(i);</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">value</span> = localStorage.getItem(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">localStorage.removeItem('x'); <span class="comment">// remove x</span></span><br><span class="line">localStorage.clear();  <span class="comment">// remove all data</span></span><br></pre></td></tr></table></figure><h3 id="cookie及其操作"><a href="#cookie及其操作" class="headerlink" title="cookie及其操作"></a>cookie及其操作</h3><ul><li>cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。</li><li>通过读写cookie检测是否支持</li><li>cookie属性有<strong>名</strong>，<strong>值</strong>，<strong>max-age</strong>，<strong>path</strong>, <strong>domain</strong>，<strong>secure</strong>；</li><li>cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置<strong>max-age=seconds</strong>属性告诉浏览器cookie有效期</li><li>cookie作用域通过<strong>文档源</strong>和<strong>文档路径</strong>来确定，通过<strong>path</strong>和<strong>domain</strong>进行配置，web页面同目录或子目录文档都可访问</li><li>通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下</li><li>读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=qiu; max-age=9999; path=/; domain=domain; secure'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=aaa; path=/; domain=domain; secure'</span>;</span><br><span class="line"><span class="comment">// 要改变cookie的值，需要使用相同的名字、路径和域，新的值</span></span><br><span class="line"><span class="comment">// 来设置cookie，同样的方法可以用来改变有效期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置max-age为0可以删除指定cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取cookie，访问document.cookie返回键值对组成的字符串，</span></span><br><span class="line"><span class="comment">//不同键值对之间用'; '分隔。通过解析获得需要的值</span></span><br></pre></td></tr></table></figure><h3 id="javascript有哪些方法定义对象"><a href="#javascript有哪些方法定义对象" class="headerlink" title="javascript有哪些方法定义对象"></a>javascript有哪些方法定义对象</h3><ol><li>对象字面量： <code>var obj = {};</code></li><li>构造函数： <code>var obj = new Object();</code></li><li>Object.create(): <code>var obj = Object.create(Object.prototype);</code></li></ol><h3 id="运算符判断相等的流程是怎样的"><a href="#运算符判断相等的流程是怎样的" class="headerlink" title="===运算符判断相等的流程是怎样的"></a>===运算符判断相等的流程是怎样的</h3><ol><li>如果两个值不是相同类型，它们不相等</li><li>如果两个值都是null或者都是undefined，它们相等</li><li>如果两个值都是布尔类型true或者都是false，它们相等</li><li>如果其中有一个是<strong>NaN</strong>，它们不相等</li><li>如果都是数值型并且数值相等，他们相等， -0等于0</li><li>如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等</li><li>如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等</li></ol><h3 id="运算符判断相等的流程是怎样的-1"><a href="#运算符判断相等的流程是怎样的-1" class="headerlink" title="==运算符判断相等的流程是怎样的"></a>==运算符判断相等的流程是怎样的</h3><ol><li>如果两个值类型相同，按照===比较方法进行比较</li><li>如果类型不同，使用如下规则进行比较<ol><li>如果其中一个值是null，另一个是undefined，它们相等</li><li>如果一个值是<strong>数字</strong>另一个是<strong>字符串</strong>，将<strong>字符串转换为数字</strong>进行比较</li><li>如果有布尔类型，将<strong>true转换为1，false转换为0</strong>，然后用==规则继续比较</li><li>如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较</li><li><strong>其他所有情况都认为不相等</strong></li></ol></li></ol><h3 id="对象到字符串的转换步骤"><a href="#对象到字符串的转换步骤" class="headerlink" title="对象到字符串的转换步骤"></a>对象到字符串的转换步骤</h3><ol><li>如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果</li><li>如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果</li><li>否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError</li></ol><h3 id="对象到数字的转换步骤"><a href="#对象到数字的转换步骤" class="headerlink" title="对象到数字的转换步骤"></a>对象到数字的转换步骤</h3><pre><code>1. 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果2. 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果3. 否则，throws a TypeError</code></pre><h3 id="lt-gt-lt-gt-的比较规则"><a href="#lt-gt-lt-gt-的比较规则" class="headerlink" title="&lt;,&gt;,&lt;=,&gt;=的比较规则"></a>&lt;,&gt;,&lt;=,&gt;=的比较规则</h3><p>所有比较运算符都支持任意类型，但是<strong>比较只支持数字和字符串</strong>，所以需要执行必要的转换然后进行比较，转换规则如下:</p><ol><li>如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错</li><li>经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）</li><li>否则，如果有一个操作数不是字符串，<strong>将两个操作数转换为数字</strong>进行比较</li></ol><h3 id="运算符工作流程"><a href="#运算符工作流程" class="headerlink" title="+运算符工作流程"></a>+运算符工作流程</h3><ol><li>如果有操作数是对象，转换为原始值</li><li>此时如果有<strong>一个操作数是字符串</strong>，其他的操作数都转换为字符串并执行连接</li><li>否则：<strong>所有操作数都转换为数字并执行加法</strong></li></ol><h3 id="函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组"><a href="#函数内部arguments变量有哪些特性-有哪些属性-如何将它转换为数组" class="headerlink" title="函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组"></a>函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组</h3><ul><li>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象</li><li>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参</li><li>arguments.length为实参的个数（Function.length表示形参长度）</li><li>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化</li><li>arguments.caller为调用当前函数的函数（已被遗弃）</li><li>转换为数组：<code>var args = Array.prototype.slice.call(arguments, 0);</code></li></ul><h3 id="DOM事件模型是如何的-编写一个EventUtil工具类实现事件管理兼容"><a href="#DOM事件模型是如何的-编写一个EventUtil工具类实现事件管理兼容" class="headerlink" title="DOM事件模型是如何的,编写一个EventUtil工具类实现事件管理兼容"></a>DOM事件模型是如何的,编写一个EventUtil工具类实现事件管理兼容</h3><ul><li>DOM事件包含捕获（capture）和冒泡（bubble）两个阶段：捕获阶段事件从window开始触发事件然后通过祖先节点一次传递到触发事件的DOM元素上；冒泡阶段事件从初始元素依次向祖先节点传递直到window</li><li>标准事件监听elem.addEventListener(type, handler, capture)/elem.removeEventListener(type, handler, capture)：handler接收保存事件信息的event对象作为参数，event.target为触发事件的对象，handler调用上下文this为绑定监听器的对象，event.preventDefault()取消事件默认行为，event.stopPropagation()/event.stopImmediatePropagation()取消事件传递</li><li>老版本IE事件监听elem.attachEvent(‘on’+type, handler)/elem.detachEvent(‘on’+type, handler)：handler不接收event作为参数，事件信息保存在window.event中，触发事件的对象为event.srcElement，handler执行上下文this为window使用闭包中调用handler.call(elem, event)可模仿标准模型，然后返回闭包，保证了监听器的移除。event.returnValue为false时取消事件默认行为，event.cancleBubble为true时取消时间传播</li><li>通常利用事件冒泡机制托管事件处理程序提高程序性能。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跨浏览器事件处理工具。只支持冒泡。不支持捕获</span></span><br><span class="line"><span class="comment"> * @author  (qiu_deqing@126.com)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    getEvent: <span class="keyword">function</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">event</span> || window<span class="variable">.event</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: <span class="keyword">function</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">event</span><span class="variable">.target</span> || <span class="keyword">event</span><span class="variable">.srcElement</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 返回注册成功的监听器，IE中需要使用返回值来移除监听器</span></span><br><span class="line">    on: <span class="keyword">function</span> (elem, <span class="keyword">type</span>, handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem<span class="variable">.addEventListener</span>) &#123;</span><br><span class="line">            elem<span class="variable">.addEventListener</span>(<span class="keyword">type</span>, handler, false);</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elem<span class="variable">.attachEvent</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> wrapper = <span class="keyword">function</span> () &#123;</span><br><span class="line">              <span class="keyword">var</span> <span class="keyword">event</span> = window<span class="variable">.event</span>;</span><br><span class="line">              <span class="keyword">event</span><span class="variable">.target</span> = <span class="keyword">event</span><span class="variable">.srcElement</span>;</span><br><span class="line">              handler<span class="variable">.call</span>(elem, <span class="keyword">event</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            elem<span class="variable">.attachEvent</span>('on' + <span class="keyword">type</span>, wrapper);</span><br><span class="line">            <span class="keyword">return</span> wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    off: <span class="keyword">function</span> (elem, <span class="keyword">type</span>, handler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elem<span class="variable">.removeEventListener</span>) &#123;</span><br><span class="line">            elem<span class="variable">.removeEventListener</span>(<span class="keyword">type</span>, handler, false);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elem<span class="variable">.detachEvent</span>) &#123;</span><br><span class="line">            elem<span class="variable">.detachEvent</span>('on' + <span class="keyword">type</span>, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: <span class="keyword">function</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">event</span><span class="variable">.preventDefault</span>) &#123;</span><br><span class="line">            <span class="keyword">event</span><span class="variable">.preventDefault</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ('returnValue' in <span class="keyword">event</span>) &#123;</span><br><span class="line">            <span class="keyword">event</span><span class="variable">.returnValue</span> = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: <span class="keyword">function</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">event</span><span class="variable">.stopPropagation</span>) &#123;</span><br><span class="line">            <span class="keyword">event</span><span class="variable">.stopPropagation</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ('cancelBubble' in <span class="keyword">event</span>) &#123;</span><br><span class="line">            <span class="keyword">event</span><span class="variable">.cancelBubble</span> = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * keypress事件跨浏览器获取输入字符</span></span><br><span class="line"><span class="comment">     * 某些浏览器在一些特殊键上也触发keypress，此时返回null</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     getChar: <span class="keyword">function</span> (<span class="keyword">event</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">event</span><span class="variable">.which</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> String<span class="variable">.fromCharCode</span>(<span class="keyword">event</span><span class="variable">.keyCode</span>);  <span class="comment">// IE</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">event</span><span class="variable">.which</span> != <span class="number">0</span> &amp;&amp; <span class="keyword">event</span><span class="variable">.charCode</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> String<span class="variable">.fromCharCode</span>(<span class="keyword">event</span><span class="variable">.which</span>);    <span class="comment">// the rest</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">// special key</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="评价一下三种方法实现继承的优缺点-并改进"><a href="#评价一下三种方法实现继承的优缺点-并改进" class="headerlink" title="评价一下三种方法实现继承的优缺点,并改进"></a>评价一下三种方法实现继承的优缺点,并改进</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rect</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">Rect.prototype = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">Rect.prototype = Shape.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line">Rect.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line">Rect.prototype.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法1：</p><ol><li>优点：正确设置原型链实现继承</li><li>优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值</li><li>缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</li><li>缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置</li><li>总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化</li></ol><p>方法2：</p><ol><li>优点：正确设置原型链实现继承</li><li>缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</li></ol><p>方法3：</p><ol><li>优点：正确设置原型链且避免方法1.2中的缺点</li><li>缺点：ES5方法需要注意兼容性</li></ol><p>改进：</p><ol><li>所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用新创建的对象替代子类默认原型，设置<code>Rect.prototype.constructor = Rect;</code>保证一致性</li><li>第三种方法的polyfill：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    f.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识点总结CSS篇（问题实例）</title>
      <link href="/2019/08/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93CSS%E7%AF%87%EF%BC%88%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B%EF%BC%89/"/>
      <url>/2019/08/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93CSS%E7%AF%87%EF%BC%88%E9%97%AE%E9%A2%98%E5%AE%9E%E4%BE%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-优化、提高性能的方法有哪些？"><a href="#CSS-优化、提高性能的方法有哪些？" class="headerlink" title="CSS 优化、提高性能的方法有哪些？"></a>CSS 优化、提高性能的方法有哪些？</h3><ul><li><p>多个 css 合并，尽量减少 HTTP 请求</p></li><li><p>css 雪碧图</p><a id="more"></a></li><li><p>抽象提取公共样式，减少代码量</p></li><li><p>选择器优化嵌套，尽量避免层级过深 （用‘&gt;’替换‘ ’）</p></li><li><p>属性值为 0 时，不加单位</p></li><li><p>压缩CSS代码</p></li><li><p>避免使用 <a href="http://www.divcss5.com/css3-style/c50224.shtml" target="_blank" rel="noopener">CSS 表达式</a></p><ul><li><p>它们要计算成千上万次并且可能会对你页面的性能产生影响。</p><p>​</p></li></ul></li></ul><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h3><ul><li>link 是 HTML 方式， @import 是 CSS 方式</li><li>link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现 FOUC</li><li>link 可以通过 rel=”alternate stylesheet” 指定候选样式</li><li>浏览器对 link 支持早于@import ，可以使用 @import 对老浏览器隐藏样式</li><li>@import 必须在样式规则之前，可以在 css 文件中引用其他文件</li><li>总体来说：link 优于@import</li></ul><h3 id="CSS-有哪些继承属性"><a href="#CSS-有哪些继承属性" class="headerlink" title="CSS 有哪些继承属性"></a>CSS 有哪些继承属性</h3><ul><li>关于文字排版的属性如：<ul><li>font</li><li>word-break</li><li>letter-spacing</li><li>text-align</li><li>text-rendering</li><li>word-spacing</li><li>white-space</li><li>text-indent</li><li>text-transform</li><li>text-shadow</li></ul></li><li>line-height</li><li>color</li><li>visibility</li><li>cursor</li></ul><h3 id="display-有哪些值？说明他们的作用"><a href="#display-有哪些值？说明他们的作用" class="headerlink" title="display 有哪些值？说明他们的作用"></a>display 有哪些值？说明他们的作用</h3><ul><li>block 像块类型元素一样显示。</li><li>none  此元素将显示为块级元素，此元素前后会带有换行符。</li><li>inline  内联元素，元素前后没有换行符。</li><li>inline-block 象行内元素一样定位，但其内容象块类型元素一样显示。</li><li>list-item 象块类型元素一样显示，并添加样式列表标记。</li><li>table 此元素会作为块级表格来显示</li><li>inherit 规定应该从父元素继承 display 属性的值</li></ul><h3 id="position-有哪些值？-relative-和-absolute-定位原点是？"><a href="#position-有哪些值？-relative-和-absolute-定位原点是？" class="headerlink" title="position 有哪些值？ relative 和 absolute 定位原点是？"></a>position 有哪些值？ relative 和 absolute 定位原点是？</h3><ul><li>absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。</li><li>fixed （老 IE 不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。</li><li>relative 生成相对定位的元素，相对于其正常位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li><li>inherit 规定从父元素继承 position 属性的值</li></ul><h3 id="CSS3新特性？"><a href="#CSS3新特性？" class="headerlink" title="CSS3新特性？"></a>CSS3新特性？</h3><ul><li>新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型 display: flex;</li><li>多列布局 column-count: 5;</li><li>媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度 color: rgba(255, 0, 0, 0.75);</li><li>圆角 border-radius: 5px;</li><li>渐变 background:linear-gradient(red, green, blue);</li><li>阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影 box-reflect: below 2px;</li><li>文字装饰 text-stroke-color: red;</li><li>文字溢出 text-overflow:ellipsis;</li><li>背景效果 background-size: 100px 100px;</li><li>边框效果 border-image:url(bt_blue.png) 0 10;</li><li>平滑过渡 transition: all .3s ease-in .1s;</li><li>动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li><li>变形 transform<ul><li>旋转 transform: rotate(20deg);</li><li>倾斜 transform: skew(150deg, -10deg);</li><li>位移 transform: translate(20px, 20px);</li><li>缩放 transform: scale(.5);</li></ul></li></ul><h3 id="如何水平居中一个元素？"><a href="#如何水平居中一个元素？" class="headerlink" title="如何水平居中一个元素？"></a>如何水平居中一个元素？</h3><p>如果需要居中的元素为inline或inline-block，为父元素设置 <code>text-align: center;</code>即可实现</p><p>如果要居中的元素为一个块级元素的话，一般使用 <code>margin: 0 auto;</code> 进行居中。</p><h3 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a>用纯 CSS 创建一个三角形的原理是什么？</h3><p>把border的其他三条边设为透明<br>注意，这里要把 <code>border-width</code> 、<code>border-style</code>、 <code>border-color</code> 分开写。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tri</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？-也称幽灵字符"><a href="#li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？-也称幽灵字符" class="headerlink" title="li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？(也称幽灵字符)"></a>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？(也称幽灵字符)</h3><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了</p><h3 id="display-inline-block-什么时候会显示间隙？-携程"><a href="#display-inline-block-什么时候会显示间隙？-携程" class="headerlink" title="display:inline-block 什么时候会显示间隙？(携程)"></a>display:inline-block 什么时候会显示间隙？(携程)</h3><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><h3 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？</h3><ul><li>响应式设计就是网站能够兼容多个不同大小的终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用 CSS3 媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的 IE，可采用 JS 获取屏幕宽度，然后通过监听window.onresize 方法来实现兼容</li></ul><h3 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h3><p>浮动的框可以向左或向右移动，<strong>直到他的外边缘碰到包含框或另一个浮动框的边框为止</strong>。 <strong>浮动框脱离文档流</strong>，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p><p>清除方法：</p><ol><li>父级 div 定义伪类：after 和 zoom (推荐使用，建议定义公共类，以减少 CSS 代码)</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在结尾处添加空 div 标签 clear:both<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfloat"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;<span class="attribute">float</span>:left&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>父级 div 定义 overflow:auto。 同时需要父级指定宽度</p><p>参考链接<a href="https://www.cnblogs.com/nxl0908/p/7245460.html" target="_blank" rel="noopener">几种常用的清除浮动方法</a></p><h3 id="box-sizing-常用的属性有哪些？分别有什么作用？"><a href="#box-sizing-常用的属性有哪些？分别有什么作用？" class="headerlink" title="box-sizing 常用的属性有哪些？分别有什么作用？"></a>box-sizing 常用的属性有哪些？分别有什么作用？</h3><ul><li>box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果</li><li>box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果</li><li>box-sizing: inherit; // 继承父元素 box-sizing 属性的值</li></ul><h3 id="请列举几种隐藏元素的方法"><a href="#请列举几种隐藏元素的方法" class="headerlink" title="请列举几种隐藏元素的方法"></a>请列举几种隐藏元素的方法</h3><ul><li>visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li><li>opacity: 0; CSS3 属性，设置 0 可以使一个元素完全透明</li><li>position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外</li><li>display: none; 元素会变得不可见，并且不会再占用文档的空间。</li><li>transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li><li>&lt;div hidden=”hidden”&gt; HTML5 属性,效果和 display:none;相同，但这个属性用于记录一个元素的状态</li><li>height: 0; 将元素高度设为 0 ，并消除边框</li><li>filter: blur(0); CSS3 属性，将一个元素的模糊度设置为 0</li></ul><h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h3><ul><li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li><li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li></ul><h3 id="css-属性-content-有什么作用？"><a href="#css-属性-content-有什么作用？" class="headerlink" title="css 属性 content 有什么作用？"></a>css 属性 content 有什么作用？</h3><p>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</p><h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><p>元素竖向的百分比设定是相对于容器的宽度，而不是高度</p><h3 id="a-标签上四个伪类的使用顺序是怎么样的？"><a href="#a-标签上四个伪类的使用顺序是怎么样的？" class="headerlink" title="a 标签上四个伪类的使用顺序是怎么样的？"></a>a 标签上四个伪类的使用顺序是怎么样的？</h3><p>link &gt; visited &gt; hover &gt; active<br>简称 lvha(love-ha)</p><p>伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活） </p><p>在这里，比如把hover放在active后面，那么实际你在激活（active）链接的时候就触发了hover伪类，hover在后面覆盖了active的颜色，所以始终无法看到active的颜色 </p><h3 id="伪元素和伪类的区别和作用？"><a href="#伪元素和伪类的区别和作用？" class="headerlink" title="伪元素和伪类的区别和作用？"></a>伪元素和伪类的区别和作用？</h3><p>伪元素:在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">"第一章："</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">"Hot!"</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><p>伪类: 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure><h3 id="before-和-after-中双冒号和单冒号有什么区别？"><a href="#before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="::before 和 :after 中双冒号和单冒号有什么区别？"></a>::before 和 :after 中双冒号和单冒号有什么区别？</h3><ul><li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li><li>伪元素在 CSS1 中已存在，当时语法是用 : 表示，如 :before 和 :after</li><li>后来在 CSS3 中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li><li>由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li><li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容 IE 的老语法</li></ul><h3 id="设置元素浮动后，该元素的-display-值会如何变化？"><a href="#设置元素浮动后，该元素的-display-值会如何变化？" class="headerlink" title="设置元素浮动后，该元素的 display 值会如何变化？"></a>设置元素浮动后，该元素的 display 值会如何变化？</h3><p>设置元素浮动后，该元素的 display 值自动变成 block</p><h3 id="请解释-CSS-sprites，以及你要如何在页面或网站中实现它"><a href="#请解释-CSS-sprites，以及你要如何在页面或网站中实现它" class="headerlink" title="请解释 CSS sprites，以及你要如何在页面或网站中实现它"></a>请解释 CSS sprites，以及你要如何在页面或网站中实现它</h3><ul><li>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。</li><li>CSS Sprites 为一些大型的网站节约了带宽，让提高了用户的加载速度和用户体验，不需要加载更多的图片。</li></ul><h3 id="base64的使用"><a href="#base64的使用" class="headerlink" title="base64的使用"></a>base64的使用</h3><ul><li>写入CSS， 减少HTTP请求</li><li>适用于小图片</li><li>base64的体积约为原图4/3</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识点总结CSS篇（基础回顾））</title>
      <link href="/2019/08/21/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93CSS%E7%AF%87%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%89/"/>
      <url>/2019/08/21/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93CSS%E7%AF%87%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>Cascading Style Sheet 层叠样式表</p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><a href="https://blog.csdn.net/YauCheun/article/details/99928622" target="_blank" rel="noopener">CSS选择器</a></h3><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><a id="more"></a><p>盒模型有两种， IE 怪异盒子模型、W3C标准盒子模型；</p><p>盒模型是由： 内容(content)、内边距(padding)、边框(border)、外边距(margin) 组成的。</p><p>标准模型的宽高是指的content区宽高；<br>IE盒模型的宽高是指的content+padding+border的宽高。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTI2NTM5Ni8yMDE3MTEvMTI2NTM5Ni0yMDE3MTExOTE0MzcwMzY1Ni0xMzMyODU3MzIxLnBuZw" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTI2NTM5Ni8yMDE3MTEvMTI2NTM5Ni0yMDE3MTExOTE0NDIyOTE1Ni00OTk0NTgwOC5wbmc" alt="在这里插入图片描述"></p><h3 id="CSS如何设置这两种盒模型？"><a href="#CSS如何设置这两种盒模型？" class="headerlink" title="CSS如何设置这两种盒模型？"></a>CSS如何设置这两种盒模型？</h3><p>标准盒模型：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">box</span>-sizing: <span class="built_in">content</span>-<span class="built_in">box</span>;</span><br></pre></td></tr></table></figure><p>怪异盒模型：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">box</span>-sizing: <span class="built_in">border</span>-<span class="built_in">box</span>;</span><br></pre></td></tr></table></figure><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://www.jianshu.com/p/0d713b32cd0d" target="_blank" rel="noopener">什么是BFC</a></p><p>W3C对BFC定义：</p><blockquote><p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p></blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p>BFC作用：</p><ol><li>利用BFC避免外边距折叠</li><li>清除内部浮动 （撑开高度）<ol><li>原理: 触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内</li></ol></li><li>避免文字环绕</li><li>分属于不同的BFC时，可以阻止margin重叠</li><li>多列布局中使用BFC</li></ol><p>如何生成BFC：（脱离文档流，满足下列的任意一个或多个条件即可）</p><ol><li>根元素，即HTML元素（最大的一个BFC）</li><li>float的值不为none</li><li>position的值为absolute或fixed</li><li>overflow的值不为visible（默认值。内容不会被修剪，会呈现在元素框之外）</li><li>display的值为inline-block、table-cell、table-caption</li></ol><p>BFC布局规则：</p><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>属于同一个BFC的两个相邻的Box的margin会发生重叠</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置float</li><li>BFC的区域不会与float box重叠。</li><li>计算BFC的高度，浮动元素也参与计算</li></ol><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li>元素”浮动”</li><li>脱离文档流</li><li>不脱离文本流</li><li>位置尽量靠上，并靠左或右</li></ul><p>对自己的影响</p><ul><li>形成”块”(BFC)</li><li>这个块会负责自己的布局，宽高由自己决定</li></ul><p>比如 span 中用 float 这个span就形成了一个BFC，就可以设置宽高了</p><p>对兄弟元素的影响</p><ul><li>上面一般贴非float元素</li><li>靠边贴float元素或边</li><li>不影响其他块级元素位置</li><li>影响其他块级元素文本</li></ul><p>对父级元素的影响</p><ul><li>从布局上”消失”</li><li>高度塌陷</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动的元素布局时不会占据父元素的布局空间，即父元素布局时不会管浮动元素，浮动元素有可能超出父元素，从而对其他元素造成影响。</p><p>方法一：使用带 clear 属性的空元素 在浮动元素后使用一个空元素如<div class="clear"></div>，并在 CSS 中赋 予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear">或<hr class="clear">来进行清理。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"news"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"news-pic.jpg"</span> /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"clear"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>优点：简单，代码少，浏览器兼容性好。<br>缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。</p><p>方法二： 使用 CSS 的 overflow 属性 给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在 IE6 中 还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的 效果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class="news"&gt;</span><br><span class="line">&lt;img src="news-pic.jpg" /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>方法三：给浮动的元素的容器添加浮动 给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布 局，不推荐使用。</p><p> 方法四：使用邻接元素处理 什么都不做，给浮动元素后面的元素添加 clear 属性。 </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.<span class="attribute">content</span>&#123;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"news"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"news-pic.jpg"</span> /&gt;</span><br><span class="line">&lt;p&gt;some text&lt;/p&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>方法五：使用 CSS 的:after 伪元素 结合 :after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。 给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素 实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">news </span>&#123;</span><br><span class="line">  background-color: gray;</span><br><span class="line"><span class="symbol">  border:</span> solid <span class="number">1</span>px black;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news <span class="class">img </span>&#123;</span><br><span class="line"><span class="symbol">  float:</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.news <span class="class">p </span>&#123;</span><br><span class="line"><span class="symbol">  float:</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after&#123;</span><br><span class="line"><span class="symbol">  content:</span> <span class="string">"020"</span>; </span><br><span class="line"><span class="symbol">  display:</span> block; </span><br><span class="line"><span class="symbol">  height:</span> <span class="number">0</span>; </span><br><span class="line"><span class="symbol">  clear:</span> both; </span><br><span class="line"><span class="symbol">  visibility:</span> hidden;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">clearfix </span>&#123;</span><br><span class="line">  <span class="comment">/* 触发 hasLayout */</span> </span><br><span class="line"><span class="symbol">  zoom:</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="params">&lt;div class="news clearfix"&gt;</span></span><br><span class="line"><span class="params">&lt;img src="news-pic.jpg" /&gt;</span></span><br><span class="line"><span class="params">&lt;p&gt;</span>some text<span class="params">&lt;/p&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h3 id="inline-block的间隙"><a href="#inline-block的间隙" class="headerlink" title="inline-block的间隙"></a>inline-block的间隙</h3><p>两个并列的inline-block中间会有一条裂缝，这个的原因是两个标签之间有空格，浏览器把这些空格当成文字中空格，所以这两个块中间多少有间隙。</p><p>解决办法：</p><ol><li>删除两个标签间的空格，但是这样html排版不好</li><li>容器元素font-size: 0 然后再在里面再重新设置字体大小<h3 id="文字换行"><a href="#文字换行" class="headerlink" title="文字换行"></a>文字换行</h3></li></ol><ul><li>overflow-wrap(word-wrap)通用换行控制<ul><li>是否保留单词</li></ul></li><li>word-break 针对多字节文本文字<ul><li>中文句子也是单词</li></ul></li><li>white-space 空白处是否换行</li></ul><h3 id="装饰属性及其他"><a href="#装饰属性及其他" class="headerlink" title="装饰属性及其他"></a>装饰属性及其他</h3><ul><li>字重（粗体） font-weight</li><li>斜体  font-style: itatic</li><li>下划线   text-decoration</li><li>指针  cursor<h3 id="单行文本溢出显示省略号"><a href="#单行文本溢出显示省略号" class="headerlink" title="单行文本溢出显示省略号"></a>单行文本溢出显示省略号</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">no-wrap</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure><h3 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display: none; 与 visibility: hidden; 的区别"></a>display: none; 与 visibility: hidden; 的区别</h3><p>相同： 它们都能让元素不可见</p><p>区别：</p><ul><li>display:none;会让元素完全<strong>从渲染树中消失</strong>，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了 hidden，通过设置 <strong>visibility: visible;可以让子孙节点显式</strong></li><li>修改常规流中元素的 display 通常会造成文档<strong>重排</strong>。修改 visibility 属性只会造成本元素的重绘</li><li>读屏器不会读取 display: none;元素内容；会读取 visibility: hidden 元素内容</li><li>无论是 display:none; 还是 visibility: hidden; 他们都依然可以被 JS 所获取到</li></ul><h3 id="外边距折叠-collapsing-margins"><a href="#外边距折叠-collapsing-margins" class="headerlink" title="外边距折叠(collapsing margins)"></a>外边距折叠(collapsing margins)</h3><p>外边距重叠就是 margin-collapse</p><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p><p>折叠结果遵循下列计算规则：</p><ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li><li>两个外边距一正一负时，折叠结果是两者的相加的和</li></ul><p>新手在做导航栏的时候发现页面整体掉下来一截就是这个原因。</p><h3 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h3><ol><li><p>px  绝对单位。传统上一个像素对应于计算机屏幕上的一个点，而对于高清屏则对应更多。</p></li><li><p>%   父元素<strong>宽度</strong>的比例。</p><ol><li>如果对 html 元素设置 font-size 为百分比值，则是以浏览器默认的字体大小16px为参照计算的（所有浏览器的默认字体大小都为 16px），如62.5%即等于10px（62.5% * 16px = 10px）。</li></ol></li><li><p>em  相对单位。 不同的属性有不同的参照值。</p><ol><li>对于字体大小属性（font-size）来说，em 的计算方式是相对于父元素的字体大小</li><li>border, width, height, padding, margin, line-height）在这些属性中，使用em单位的计算方式是参照该元素的 font-size，1em 等于该元素设置的字体大小。同理如果该元素没有设置，则一直向父级元素查找，直到找到，如果都没有设置大小，则使用浏览器默认的字体大小。</li></ol></li><li><p>rem 是相对于根元素 html 的 font-size 来计算的，所以其参照物是固定的。</p><ol><li>好处：rem 只需要修改 html 的 font-size 值即可达到全部的修改，即所谓的牵一发而动全身。</li></ol></li><li><p>vw, vh, vmin, vmax   相对单位，是基于视窗大小（浏览器用来显示内容的区域大小）来计算的。</p><ol><li>vw：基于视窗的宽度计算，1vw 等于视窗宽度的百分之一</li><li>vh：基于视窗的高度计算，1vh 等于视窗高度的百分之一</li><li>vmin：基于vw和vh中的最小值来计算，1vmin 等于最小值的百分之一</li><li>vmax：基于vw和vh中的最大值来计算，1vmax 等于最大值的百分之一</li></ol></li></ol><h3 id="transform变形"><a href="#transform变形" class="headerlink" title="transform变形"></a><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform" target="_blank" rel="noopener">transform变形</a></h3><p>与transition、translate名字有点像，transition是做过渡动画的，而translate是用来做平移的。</p><ul><li>none    <ul><li>定义不进行转换。</li><li>matrix(n,n,n,n,n,n)</li><li>定义 2D 转换，使用六个值的矩阵。</li></ul></li><li>translate(x,y)<ul><li>从其当前位置移动，根据给定的 left（x 坐标）和 top（y 坐标）</li></ul></li><li>translate3d(x,y,z)<ul><li>定义 3D 转换。</li></ul></li><li>translateX(x)</li><li>translateY(y)</li><li>translateZ(z)</li><li>scale(x[,y]?)<ul><li>定义 2D 缩放转换。</li><li>scale3d(x,y,z)</li><li>定义 3D 缩放转换。</li><li>scaleX(x)</li><li>scaleY(y)</li><li>scaleZ(z)</li><li>rotate(angle)</li><li>定义 2D 旋转，在参数中规定角度。</li><li>rotate3d(x,y,z,angle)</li><li>定义 3D 旋转。</li><li>rotateX(angle)</li><li>rotateY(angle)</li><li>rotateZ(angle)</li></ul></li><li>skew(x-angle,y-angle)<ul><li>定义沿着 X 和 Y 轴的 2D 倾斜转换。</li></ul></li><li>skewX(angle)</li><li>skewY(angle)<ul><li>perspective(n)</li><li>为 3D 转换元素定义透视视图。</li></ul></li></ul><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><ul><li>嵌套           <ul><li>反映层级和约束</li></ul></li><li>变量和计算      <ul><li>减少冗余代码</li></ul></li><li>entend和mixin  <ul><li>代码片段重用</li><li>mixin是直接把CSS代码每个地方重复写一份</li><li>extend是使用逗号分割的选择器来为多个不同的地方使用同一段CSS</li></ul></li><li>循环          <ul><li>适用于复杂有规律的样式</li></ul></li><li>import        <ul><li>CSS模块化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器及优先级权重</title>
      <link href="/2019/08/21/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%E6%9D%83%E9%87%8D/"/>
      <url>/2019/08/21/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%E6%9D%83%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-选择器分类"><a href="#CSS-选择器分类" class="headerlink" title="CSS 选择器分类"></a>CSS 选择器分类</h3><ul><li><p>标签选择 （div）</p></li><li><p>id选择器 （#id）</p></li><li><p>class选择器  (.class)</p><a id="more"></a></li><li><p>后代选择 （div a）</p></li><li><p>子代选择 （div &gt; p）</p></li><li><p>相邻选择 （div + p）</p></li><li><p>通配符选择 （*）</p></li><li><p>否定选择器 :not(.link){}</p></li><li><p>属性选择器</p></li><li><p>伪类选择器</p></li><li><p>伪元素选择器 ::before{}</p></li></ul><h3 id="CSS3属性选择器"><a href="#CSS3属性选择器" class="headerlink" title="CSS3属性选择器"></a>CSS3属性选择器</h3><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>[attribute]</td><td>用于选取带有指定属性的元素。</td></tr><tr><td>[attribute=value]</td><td>用于选取带有指定属性和值的元素。</td></tr><tr><td>[attribute~=value]</td><td>用于选取属性值中包含指定词汇的元素。</td></tr><tr><td>[attribute|=value]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td></tr><tr><td>[attribute^=value]</td><td>匹配属性值以指定值开头的每个元素。</td></tr><tr><td>[attribute$=value]</td><td>匹配属性值以指定值结尾的每个元素。</td></tr><tr><td>[attribute*=value]</td><td>匹配属性值中包含指定值的每个元素。</td></tr></tbody></table><h3 id="CSS3伪类选择器"><a href="#CSS3伪类选择器" class="headerlink" title="CSS3伪类选择器"></a>CSS3伪类选择器</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes#%E6%A0%87%E5%87%86%E4%BC%AA%E7%B1%BB%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">伪类 | MDN</a><br>常用：</p><ul><li>:hover</li><li>:focus</li><li>:after 在元素之前添加内容,也可以用来做清除浮动。</li><li>:before 在元素之后添加内容</li><li>:enabled 选择器匹配每个已启用的元素（大多用在表单元素上）。</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中</li><li>::selection  用户选中的区域</li><li>:empty   一般用来隐藏内部什么都没有的元素</li><li>:not(selecter)</li><li>​</li><li>p:first-of-type </li><li>p:last-of-type </li><li>p:only-of-type </li><li>p:nth-of-type(n)</li><li>p:nth-last-of-type(n)</li><li>​</li><li>:nth-child(n)</li><li>:nth-last-child(n)</li><li>p:only-child </li></ul><h3 id="伪类和伪元素区别"><a href="#伪类和伪元素区别" class="headerlink" title="伪类和伪元素区别"></a>伪类和伪元素区别</h3><ul><li>伪类值一种状态 比如:hover</li><li>伪元素是一个真实存在的元素，他可以有样式有内容</li></ul><h3 id="iconfont原理"><a href="#iconfont原理" class="headerlink" title="iconfont原理"></a>iconfont原理</h3><ul><li>利用编码让图标编为一个字符</li><li>引入字体</li><li>利用before伪元素向页面中插入一个文字</li></ul><h3 id="css-定义的权重"><a href="#css-定义的权重" class="headerlink" title="css 定义的权重"></a>css 定义的权重</h3><ul><li><p>!important 优先级最高，但也会被权重高的important所覆盖</p></li><li><p>行内样式总会覆盖外部样式表的任何样式(除了!important)</p></li><li><p>单独使用一个选择器的时候，不能跨等级使css规则生效</p></li><li><p>如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效</p></li><li><p>如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则</p></li><li><p>权重相同时，与元素距离近的选择器生</p><h5 id="权值等级划分，-一般来说是划分4个等级："><a href="#权值等级划分，-一般来说是划分4个等级：" class="headerlink" title="　　权值等级划分， 一般来说是划分4个等级："></a>　　权值等级划分， 一般来说是划分4个等级：</h5></li><li><p>第一等级：代表 内联样式，如 style=””，权值为 1,0,0,0；</p></li><li><p>第二等级：代表 ID选择器，如 #id=””, 权值为 0,1,0,0；</p></li><li><p>第三等级：代表 calss | 伪类 | 属性 选择器，如 .class | :hover,:link,:target | [type],<br> 权值 0,0,1,0；</p></li></ul><ul><li>第四等级：代表 标签 | 伪元素 选择器，如 p | ::after, ::before, ::fist-inline,<br> ::selection, 权值 0,0,0,1；</li></ul><ul><li>此外，通用选择器（*），子选择器（&gt;）， 相邻同胞选择器（+）等选择器不在4等级之内，所以它们的权值都为 0,0,0,0；<h5 id="权值计算-公式："><a href="#权值计算-公式：" class="headerlink" title="权值计算 公式："></a>权值计算 公式：</h5></li></ul><p><font color="blue" size="4">权值 = 第一等级选择器<em>个数，第二等级选择器</em>个数，第三等级选择器<em>个数，第四等级选择器</em>个数</font><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzM0NDAyLzIwMTgwMy83MzQ0MDItMjAxODAzMTUxODAyNTI5NTMtODQ5MTMzMzE0LnBuZw" alt="在这里插入图片描述"></p><p><strong>一句话总结：</strong></p><p><font color="blue" size="4">css属性!important&gt;内联样式 &gt;ID选择器(id)&gt;类选择器(.class) = 伪类选择器(:hover等) = 属性选择器[type等] &gt;元素选择器(p等) = 伪元素选择器(:after/:before/::selection等) &gt;通用选择器(*) &gt;继承的样式</font></p><h3 id="浏览器解析CSS"><a href="#浏览器解析CSS" class="headerlink" title="浏览器解析CSS"></a>浏览器解析CSS</h3><p><code>.wrapper div &gt; p</code>  CSS中，浏览器查找元素是通过选择权从后往前找的， 这样做的目的是加快CSS解析速度，从后往前，排除法</p><p><a href="https://blog.csdn.net/qq_21397815/article/details/72874932" target="_blank" rel="noopener">浏览器解析css选择器的规则</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器工作原理</title>
      <link href="/2019/06/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h1><h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><ul><li>人机交互部分（UI）</li><li>网络请求部分（Socket）</li><li>JavaScript引擎部分（解析执行JavaScript）</li><li>渲染引擎部分（渲染HTML、CSS等）</li><li>数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage）</li></ul><p>sqlite</p><a id="more"></a><h2 id="主流渲染引擎"><a href="#主流渲染引擎" class="headerlink" title="主流渲染引擎"></a>主流渲染引擎</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li><p>渲染引擎 又叫 排版引擎 或 浏览器内核。</p></li><li><p>主流的 渲染引擎 有</p><ul><li><strong>Chrome浏览器</strong>: Blink引擎（WebKit的一个分支）。</li><li><strong>Safari浏览器</strong>: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。</li><li><strong>FireFox浏览器</strong>: Gecko引擎。</li><li><strong>Opera浏览器</strong>: Blink引擎(早期版使用Presto引擎）。</li><li><strong>Internet Explorer浏览器</strong>: Trident引擎。</li><li><strong>Microsoft Edge浏览器</strong>: EdgeHTML引擎（Trident的一个分支）。</li></ul></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。</li></ol><ol start="2"><li><p>构建<em>渲染树</em>，<em>渲染树</em>并不等同于<em>Dom树</em>，因为像<code>head标签 或 display: none</code>这样的元素就没有必要放到<em>渲染树</em>中了，但是它们在<em>Dom树</em>中。</p></li><li><p>对<em>渲染树</em>进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫<code>&quot;layout&quot; 或 &quot;reflow&quot;</code>。</p></li><li><p>绘制<em>渲染树</em>，调用操作系统底层API进行绘图操作。</p></li></ol><h3 id="渲染引擎工作原理示意图"><a href="#渲染引擎工作原理示意图" class="headerlink" title="渲染引擎工作原理示意图"></a>渲染引擎工作原理示意图</h3><p><strong>渲染引擎工作原理示意图</strong></p><p><img src="https://img-blog.csdnimg.cn/201906031918046.png" alt="在这里插入图片描述"></p><p><strong>WebKit工作原理（Chrome、Safari、Opera）</strong></p><p><img src="https://img-blog.csdnimg.cn/20190603191836253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Gecko工作原理（FireFox）</strong></p><p><img src="https://img-blog.csdnimg.cn/20190603191851292.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="浏览器的-reflow-或-layout-过程"><a href="#浏览器的-reflow-或-layout-过程" class="headerlink" title="浏览器的 reflow 或 layout 过程"></a>浏览器的 reflow 或 layout 过程</h3><p><a href="https://www.youtube.com/watch?v=ZTnIxIA5KGw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZTnIxIA5KGw</a></p><h3 id="打开-Chrome-的-Rendering-功能"><a href="#打开-Chrome-的-Rendering-功能" class="headerlink" title="打开 Chrome 的 Rendering 功能"></a>打开 Chrome 的 Rendering 功能</h3><p>第一步：</p><p><img src="https://img-blog.csdnimg.cn/2019060319195911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第二步：</p><p><img src="https://img-blog.csdnimg.cn/20190603192020911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="浏览器访问网站过程"><a href="#浏览器访问网站过程" class="headerlink" title="浏览器访问网站过程"></a>浏览器访问网站过程</h2><blockquote><ol><li>在浏览器地址栏中输入网址。</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/20190603192037810.png" alt="在这里插入图片描述"></p><blockquote><ol start="2"><li>浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。</li></ol></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.taobao.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, sdch, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line"><span class="attribute">Cookie</span>: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>浏览器发起DNS解析请求，将域名转换为IP地址。</li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/20190603192052920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><ol start="4"><li>浏览器将请求报文发送给服务器。</li></ol></blockquote><blockquote><ol start="5"><li>服务器接收请求报文，并解析。</li></ol></blockquote><blockquote><ol start="6"><li>服务器处理用户请求，并将处理结果封装成HTTP响应报文。</li></ol></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span>: Tengine</span><br><span class="line"><span class="attribute">Date</span>: Thu, 13 Apr 2017 02:24:25 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">Vary</span>: Ali-Detector-Type, X-CIP-PT</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0, s-maxage=300</span><br><span class="line"><span class="attribute">Via</span>: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]</span><br><span class="line"><span class="attribute">Age</span>: 293</span><br><span class="line"><span class="attribute">X-Cache</span>: HIT TCP_MEM_HIT dirn:-2:-2</span><br><span class="line"><span class="attribute">X-Swift-SaveTime</span>: Thu, 13 Apr 2017 02:19:32 GMT</span><br><span class="line"><span class="attribute">X-Swift-CacheTime</span>: 300</span><br><span class="line"><span class="attribute">Timing-Allow-Origin</span>: *</span><br><span class="line"><span class="attribute">EagleId</span>: 9903e7e514920502659594264e</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span>: max-age=31536000</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="zh-CN"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="utf-8" /&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;</span><br><span class="line">&lt;meta name="renderer" content="webkit" /&gt;</span><br><span class="line">&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;</span><br><span class="line">&lt;meta name="spm-id" content="a21bo" /&gt;</span><br><span class="line">&lt;meta name="description" content="淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！" /&gt;</span><br><span class="line">&lt;meta name="aplus-xplug" content="NONE"&gt;</span><br><span class="line">&lt;meta name="keyword" content="淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺" /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">......</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><ol start="7"><li>服务器将HTTP响应报文发送给浏览器。</li></ol></blockquote><blockquote><ol start="8"><li>浏览器接收服务器响应的HTTP报文，并解析。</li></ol></blockquote><blockquote><ol start="9"><li>浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。</li></ol></blockquote><blockquote><ol start="10"><li>最终浏览器展示出了页面</li></ol></blockquote><h2 id="HTTP请求报文和响应报文格式"><a href="#HTTP请求报文和响应报文格式" class="headerlink" title="HTTP请求报文和响应报文格式"></a>HTTP请求报文和响应报文格式</h2><p><img src="https://img-blog.csdnimg.cn/20190603192117339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><p><img src="https://img-blog.csdnimg.cn/20190603192130205.gif" alt="在这里插入图片描述"></p><h3 id="windows-下-hosts-文件位置"><a href="#windows-下-hosts-文件位置" class="headerlink" title="windows 下 hosts 文件位置"></a>windows 下 hosts 文件位置</h3><p>C:\Windows\System32\drivers\etc\hosts</p><h2 id="DOM-解析"><a href="#DOM-解析" class="headerlink" title="DOM 解析"></a>DOM 解析</h2><p>参考代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span> <span class="attr">alt</span>=<span class="string">"example"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190603192150547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Webkit-CSS-解析"><a href="#Webkit-CSS-解析" class="headerlink" title="Webkit CSS 解析"></a>Webkit CSS 解析</h2><p><img src="https://img-blog.csdnimg.cn/20190603192216791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhdUNoZXVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="How-Browsers-work-浏览器是如何工作的"><a href="#How-Browsers-work-浏览器是如何工作的" class="headerlink" title="How Browsers work - 浏览器是如何工作的"></a>How Browsers work - 浏览器是如何工作的</h2><p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_browsers_we_will_talk_about" target="_blank" rel="noopener">How Browsers work</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 浏览器工作原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用前端技术和MySQL+PHP制作自己的一个个人博客网站</title>
      <link href="/2019/04/10/%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%92%8CMySQL+PHP%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2019/04/10/%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%92%8CMySQL+PHP%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><strong>源代码地址</strong>：<a href="https://github.com/YauCheun/BlogCode" target="_blank" rel="noopener">GitHub源码</a><br><strong>我的博客网站地址</strong>：<a href="http://www.yublog.fun/" target="_blank" rel="noopener">http://www.yublog.fun/</a><br><strong>制作前景：</strong></p><p>想拥有一个自己独自开发的一个小型博客网站，自己能发布博文管理博文。</p><a id="more"></a><p>目标：**</p><p>了解 Web 开发过程（历史）</p><p>掌握基本的动态网站开发</p><p>培养 B/S 架构应用开发思维 </p><p>锻炼 JavaScript jQuery AJAX</p><p><strong>开发流程简介</strong></p><p>了解了动态网站的概念过后，我们作为开发者更多想到的就是如何具体开发一个动态网站应用程序，有那些具体的工作，流程是怎样的？</p><p>正常情况下，我们大概会有如下几个阶段：</p><p><strong>需求分析</strong>：分析我们这个应用程序到底要去做哪些功能，应对哪些业务。</p><p><strong>原型设计</strong>：根据需求分析的结果规划应用程序的原型，可以理解为“打草稿”。</p><p><strong>UI 设计</strong>：将“草稿”转换为设计稿，并提供相应的产物（设计稿、静态页面）。</p><p><strong>技术选型</strong>：根据业务场景分别选择对应的技术栈（数据库技术栈、后端技术栈、前端技术栈），一般考虑的因素：人、业务。</p><p><strong>数据库设计</strong>：根据需求和原型分析我们有哪些类型的数据需要存，从而得到我们数据库的基本结构。</p><p><strong>项目架构设计</strong>：俗称搭架构，其中具体的操作主要就是制定项目规范约束、创建基本的项目结构、编写基础的公共模块代码和组织代码。</p><p><strong>业务迭代开发</strong>：开发者的日常，基于项目架构（条条框框）下完成各项业务功能。</p><p><strong>集中测试</strong>：将所有功能模块整合到一起过后，集中测试业务功能是否有 BUG，是否满足需求。</p><p><strong>部署上线</strong>：从开发环境向生产环境转换，就是把应用部署到服务器上。</p><p><strong>准备工作<br>1.数据库设计</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ2OTQwNy8yMDE5MDQvMTQ2OTQwNy0yMDE5MDQwODIxNDMzMzEwMi0xNjQ3OTk2MTE1LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>2.项目配置文件</strong><br>由于在接下来的开发过程中，肯定又一部分公共的成员，例如数据库名称，数据库主机，数据库用户名密码等，这些数据应该放到公共的地方，抽象成一个配置文件 config.php 放到项目根目录下。</p><p>这个配置文件采用定义常量的方式定义配置成员：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库主机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'DB_HOST'</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库用户名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'DB_USER'</span>, <span class="string">'root'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'DB_PASS'</span>, <span class="string">'111'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">define</span></span>(<span class="string">'DB_NAME'</span>, <span class="string">'111'</span>);</span><br></pre></td></tr></table></figure><p>做完了相关的准备工作好，首先编写好所有需要用到的静态页面，我这里用的是bootstrap的样式来写响应式的，把所有的页面都准备好之后然后开始编写后台的代码，</p><p>我这里后台是用PHP来写的，主要的功能有管理后台登录：即登录后具有session才能进入后台以及推出后清除当前的session；后台的仪表盘功能：用来显示此时有多少篇文章和以及评论等信息；后台文章管理功能：主要有对文章的编辑，删除以及批量删除；后台文章的新增：用的是百度的<strong>UEditor</strong>的插件，很容易就能上手使用；后台的评论管理功能：能够对评论删除以及批准和拒绝，这里用到了一个分页的插件<strong>jQuery Pagination</strong>，评论较多的话会分页；账户管理功能：当前账户能修改密码等。以下是做好的截图。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ2OTQwNy8yMDE5MDQvMTQ2OTQwNy0yMDE5MDQxNTIxMzQ0NTcxNC0xMDU0NTEyMjcucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>后台功能写完之后，下一步要做的就是把一些数据传给前台，然后前台拿到这些数据之后就把页面渲染出来，这里就要用到ajax,具体做法实在后台文件夹中建一个接口的文件夹，在里面用PHP代码写要获取的数据，然后在前台用ajax请求这个接口文件获取数据。然后把获取到的数据通过模板渲染到页面上，我的前台页面如下。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ2OTQwNy8yMDE5MDQvMTQ2OTQwNy0yMDE5MDQxNTIxNDQzMDk0OC0xMzUxMDEwODc3LnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>所有的源代码我都上传到GitHub上了，链接在下方</strong><br><strong>源代码地址</strong>：<a href="https://github.com/YauCheun/BlogCode" target="_blank" rel="noopener">GitHub源码</a><br><strong>我的博客网站地址</strong>：<a href="http://www.yublog.fun/" target="_blank" rel="noopener">http://www.yublog.fun/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 MYSQL PHP blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
